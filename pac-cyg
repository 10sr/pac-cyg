#!/bin/sh
set -e
#
# pac-cyg --- Install tool for cygwin similar to archlinux pacman
#
# Copyright (C) 2014 10sr
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# (http://www.fsf.org/licensing/licenses/gpl.html)



_mirrorlist_path=/etc/pac-cyg.mirrorlist
_version=0.1
_cachedir=/var/cache/pac-cyg
_setupdir=/etc/setup
_arch=

# newline separated mirrorlist
_mirrorlist_default="# <name> <url>
main http://mirrors.kernel.org/sourceware/cygwin"

_installed_db=$_setupdir/installed.db

##########################33
# Utilities

_msg(){
    echo ":: $*"
}

_warn(){
    echo ":: $*" 1>&2
}

_die(){
    _warn "$@"
    exit 1
}

_ask(){
    # _ask msg default
    # _ask use input with prompt MSG
    # DEFAULT must be y or n
    printf "$1 "
    read reply
    test -n "$reply" || reply="$2"
    case $reply in
        y|Y|yes|YES) return 0;;
        n|N|no|NO) return 1;;
        *) return 2;;
    esac
}

_detect_arch(){
    [ $HOSTTYPE = x86_64 ] && echo x86_64 || echo x86
}

_download(){
    # _download <url> <path>
    if type wget >/dev/null 2>&1
    then
        wget "$1" -O "$2" # -N
    elif  type curl >/dev/null 2>&1
    then
        curl --url "$1" --output "$2"
    fi
}

_get_cache_dir(){
    # _get_cache_dir <mirror_url>
    # get cache directory for mirror_url
    __mirror_dir="$_cachedir/`echo $1 | sed -e 's|/|%2f|g
s|:|%3a|g'`/$_arch"
    mkdir -p "$__mirror_dir"
    echo "$__mirror_dir"
}

_check_prepare_mirrorlist(){
    # check if $_mirrorlist_path exits, and create newly if not yet with default
    # value $_mirrorlist_default
    # TODO: check if mirrorlist is in valid format
    if test -e $_mirrorlist_path
    then
        return
    fi
    _msg $_mirrorlist_path not exists yet. creating it
    echo "$_mirrorlist_default" >$_mirrorlist_path
}

_cat_mirrorlist(){
    # cat mirrorlist with invalid line stripped
    # grep -v '^#' $_mirrorlist_path | grep '^\w\+\W\+\w\+\W\+$'
    grep -v '^#' $_mirrorlist_path
}

_is_installed(){
    # _is_installed pkgname
    # fail if pkgname is not installed yet
    cut -d " " -f 1 $_installed_db | grep --line-regexp "$1" >/dev/null 2>&1
}


##############################
# sync operations: install packages, search packages including uninstalled

do_sync(){
    if test "$1" = "-"
    then
        shift 1
    else
        unset OPTIND
        while getopts syui opt2
        do
            case "$opt2" in
                s) __search=1;;
                y) __update=1;;
                u) __upgrade=1;;
                i) __info=1;;
                *) do_help; return 1;;
            esac
        done

        shift `expr $OPTIND - 1`
    fi

    # __opts=$1
    # shift
    # for __opt in `echo "$__opts" | sed -e 's/\(.\)/\1 /g'`
    # do
    #     # iterate by one chars
    #     case $__opt in
    #         s) __search=1;;
    #         y) __update=1;;
    #         u) __upgrade=1;;
    #         i) __info=1;;
    #         *) do_help; return 1;;
    #     esac
    #     echo opt: $__opt
    # done

    if test -n "$__update"
    then
        _cat_mirrorlist | while read repname url
        do
            _update_pkglist $url
        done
    fi

    if test -n "$__upgrade"
    then
        _warn Updating feature is not supported yet. Use setup.exe .
    fi

    if test -n "$__search"
    then
        _cat_mirrorlist | while read repname url
        do
            _msg "repository [$repname]"
            for pkg in "$@"
            do
                awk '$1 ~ query && $0 = $1' RS='\n\n@ ' FS='\n' query="$pkg" \
                    `_get_cache_dir $url`/setup.ini
            done
        done
    else
        _cat_mirrorlist | while read repname url
        do
            for pkg in "$@"
            do
                awk '$1 ~ query && $0 = $1' RS='\n\n@ ' FS='\n' query="$pkg" \
                    `_get_cache_dir $url`/setup.ini
            done
        done
    fi

    if test -n "$__info"
    then
        # FIXME: this shows all packages that contain the queried strings
        _cat_mirrorlist | while read repname url
        do
            for pkg in "$@"
            do
                awk '$1 ~ query {print $0 "\n"}' RS='\n\n@ ' FS='\n' query="$pkg" \
                    `_get_cache_dir $url`/setup.ini
            done
        done
    fi

}

_update_pkglist()
{
    # _update_pkglist <mirror>
    # fetch latest setup.ini from mirror
    # TODO: use md5.sum to check if updated
    __dir=`_get_cache_dir $1`
    if _download $1/$_arch/setup.bz2 $__dir/_setup.bz2 && \
        test -e $__dir/_setup.bz2
    then
        bunzip2 $__dir/_setup.bz2
        mv $__dir/_setup $__dir/setup.ini
        _msg Package list updated
    elif _download $1/$_arch/setup.ini $__dir/_setup.ini && \
        test -e $__dir/_setup.ini
    then
        mv $__dir/_setup.ini $__dir/setup.ini
        _msg Package list updated
    else
        _die Error updating package list
    fi
}

_install(){
    # _install pkg mirror
    # this function does not check if pkg is already installed
    # use _is_installed to check it
    __dir=$_vardir
    __pkgdir=$__dir/release/$pkg
    mkdir -p $__pkgdir
    _cat_mirrorlist | while read repname mirror
    do
        awk '
            $1 == package {
                desc = $0
                px++
            }
            END {
                if (px == 1 && desc) print desc
                else print "Package not found"
            }
        ' RS='\n\n@ ' FS='\n' package="$pkg" `_get_cache_dir $mirror`/setup.ini \
            > "$__pkgdir/desc"
        if test "`cat $__pkgdir/desc`" = 'Package not found'
        then
            _msg $pkg is not found in $mirror
            rm -r $__pkgdir
            continue
        fi


        # download and unpack the bz2 or xz file

        # pick the latest version, which comes first
        __arch_path=$(awk '/^install: / {print $2; exit}' "$__pkgdir/desc")

        if test -z "$__arch_path"
        then
            _msg Cannot find archive file for $pkg in $mirror
            continue
        fi

        __md5sum=$(awk '/^install: / {print $4; exit}' $__pkgdir/desc)
        __filebase=`basename $__arch_path`
        __file=`_get_cache_dir $mirror`/$__filebase

        if test -e $__file -a $(md5sum $__file | awk NF=1) = $__md5sum
        then
            _msg $__filebase already downloaded. skip
        elif _download $mirror/$__arch_path $__file && \
            test $(md5sum $__file | awk NF=1) = $__md5sum
        then
            true
        else
            _msg downloading $__filebase failed
            return 1
        fi

        echo "Unpacking $filebase ..."
        tar xvf $file -C / > "$__pkgdir/file.lst"


        # update the package database
        awk '
    ins != 1 && pkg < $1 {
      printf "%s %s 0\n", pkg, bz
      ins=1
    }
    1
    END {
      if (ins != 1) printf "%s %s 0\n", pkg, bz
    }
    ' pkg="$pkg" bz=$file $_installed_db > /tmp/awk.$$
        mv $_installed_db{,.bak}
        mv /tmp/awk.$$ $_installed_db
    done
}




##############################
# query installed packages

do_query(){
    if test "$1" = "-"
    then
        shift 1
    else
        unset OPTIND
        while getopts siol opt2
        do
            case "$opt2" in
                s) __search=1;;
                i) __info=1;;
                o) __own=1;;
                l) __list=1;;
                *) do_help; return 1;;
            esac
        done

        shift `expr $OPTIND - 1`
    fi

    if test -z "$__search" -a -z "$__info" -a -z "$__own" -a -z "$__list"
    then
        awk 'NR>1 && $0=$1' $_installed_db
        return 0
    fi

    if test -n "$__search"
    then
        for pkg in "$@"
        do
            awk 'NR>1 && $1~query && $0=$1' query="$pkg" $_installed_db
        done
    fi

    if test -n "$__info"
    then
        echo Qi
    fi

    if test -n "$__own"
    then
        for e in "$@"
        do
            key=$(command -v "$e" | sed s./..)
            if (( ! ${#key} ))
            then
                key=$e
            fi
            for manifest in "$_setupdir"/*.lst.gz
            do
                found=$(gzip -cd $manifest | grep -c "$key" || true)
                if (( found ))
                then
                    package=$(sed '
          s,/etc/setup/,,
          s,.lst.gz,,
          ' <<< $manifest)
                    echo Found $key in the package $package
                    break
                fi
            done
        done
    fi

    if test -n "$__list"
    then
        for pkg in "$@"
        do
            zcat "$_setupdir"/"$pkg".lst.gz 2>/dev/null \
                || _warn Package not found: "$pkg"
        done
    fi
}


###############################
# remove packages

do_remove(){
    if test "$1" = "-"
    then
        shift 1
    else
        unset OPTIND
        while getopts s opt2
        do
            case "$opt2" in
                s) __recursive=1;;
                *) do_help; return 1;;
            esac
        done

        shift `expr $OPTIND - 1`
    fi

    if test -n "$__recursive"
    then
        _warn Recursive remove is not currently supported.
        _warn "-s" option is ignored.
    fi

    _msg Removing these packages:
    echo
    echo " " "$@"
    echo
    if _ask "Really remove these packages? [y/N]" n
    then
        for pkg in "$@"
        do
            _remove_package "$pkg"
        done
    else
        _warn Abort.
    fi
}

_remove_package(){
    # _remove_package pkg
    # remove one package
    pkg=$1
    if ! _is_installed "$pkg"
    then
        _warn Package $pkg is not installed, skipping
        return 0
    fi
    for req in cygwin coreutils gawk bzip2 tar wget bash
    do
        if [[ $pkg = $req ]]
        then
            _warn apt-cyg cannot remove package $pkg, skipping
            return 0
        fi
    done
    if [ ! -e "$_setupdir/$pkg.lst.gz" ]
    then
        _warn Package manifest missing, cannot remove $pkg. skipping
        return 0
    fi

    _msg Removing $pkg

    # run preremove scripts

    if [ -e "/etc/preremove/$pkg.sh" ]
    then
        "/etc/preremove/$pkg.sh"
        rm "/etc/preremove/$pkg.sh"
    fi
    gzip -cd "$_setupdir/$pkg.lst.gz" |
    awk '/[^\/]$/ {print "rm -f \"/" $0 "\""}' | sh
    rm "$_setupdir/$pkg.lst.gz"
    rm -f /etc/postinstall/$pkg.sh.done
    awk '$1 != pkg' pkg="$pkg" $_installed_db > /tmp/awk.$$
    mv ${_installed_db}{,-save}
    mv /tmp/awk.$$ $_installed_db
    _msg Package $pkg removed
}

############################
# help

function do_help()
{
    cat <<__EOC__
Usage: pac-cyg <operation> [<option> ...] [<target> ...]

Operations:
    -S    Sync packages
    -Q    Query installed packages
    -R    Remove packages
    -V    Show version
__EOC__
}


########################
# version

function do_version()
{
    echo pac-cyg v$_version
}


######################################3
# main

main(){
    _check_prepare_mirrorlist

    __ope=
    __opts=

    unset OPTIND
    while getopts SQRVsyuiolh opt
    do
        case "$opt" in
            S) __ope=sync;;
            Q) __ope=query;;
            R) __ope=remove;;
            V) __ope=version;;
            s|y|u|i|o|l) __opts=$__opts$opt;;
            h) do_help; return 0;;
            *) do_help; return 1;;
        esac
    done

    shift `expr $OPTIND - 1`

    # echo $__ope
    # echo $__opt
    # echo "$@"
    # exit 1
    case "$__ope" in
        sync) do_sync -"$__opts" "$@";;
        query) do_query -"$__opts" "$@";;
        remove) do_remove -"$__opts" "$@";;
        version) do_version -"$__opts" "$@";;
        *) do_help -"$__opts" "$@";;
    esac
}

_arch=`_detect_arch`
main "$@"
