#!/bin/bash
set -eu
#
# pac-cyg --- Install tool for cygwin similar to archlinux pacman
#
# Copyright (C) 2014 10sr
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# (http://www.fsf.org/licensing/licenses/gpl.html)



_mirrorlist_path=/etc/pac-cyg.mirrorlist
_version=0.1.1
_cachedir=/var/cache/pac-cyg
_setupdir=/etc/setup
_arch=

# newline separated mirrorlist
_mirrorlist_default="# <name> <url>
main http://mirrors.kernel.org/sourceware/cygwin"

_installed_db=$_setupdir/installed.db

##########################33
# Utilities

__tput_bold=`tput bold || true`
__tput_default=`tput sgr0 || true`
__tput_yellow=`tput setaf 3 || true`

_msg(){
    echo ">> ${__tput_bold}$*${__tput_default}"
}

_warn(){
    echo ">>> ${__tput_yellow}${__tput_bold}$*${__tput_default}" 1>&2
}

_die(){
    _warn "$@"
    exit 1
}

_ask(){
    # _ask msg default
    # _ask use input with prompt MSG
    # DEFAULT must be y or n
    printf "$1 "
    read reply
    test -n "$reply" || reply="$2"
    case $reply in
        y|Y|yes|YES) return 0;;
        n|N|no|NO) return 1;;
        *) return 2;;
    esac
}

_detect_arch(){
    # FIXME: die for unknown architecture
    [ $HOSTTYPE = x86_64 ] && echo x86_64 || echo x86
}

_download(){
    # _download <url> <path>
    if type wget >/dev/null 2>&1
    then
        wget "$1" -O "$2" # -N
    elif  type curl >/dev/null 2>&1
    then
        curl --url "$1" --output "$2"
    else
        _warn No program for download found.
        _die Install wget or curl from setup.exe first.
    fi
}

_get_cache_dir(){
    # _get_cache_dir <mirror_url>
    # get cache directory for mirror_url
    __mirror_dir="$_cachedir/`echo $1 | sed -e 's|/|%2f|g
s|:|%3a|g'`/$_arch"
    mkdir -p "$__mirror_dir"
    echo "$__mirror_dir"
}

_check_prepare_mirrorlist(){
    # check if $_mirrorlist_path exits, and create newly if not yet with default
    # value $_mirrorlist_default
    # TODO: check if mirrorlist is in valid format
    if test -e $_mirrorlist_path
    then
        return
    fi
    _msg $_mirrorlist_path not exists yet. creating it
    echo "$_mirrorlist_default" >$_mirrorlist_path
}

_cat_mirrorlist(){
    # cat mirrorlist with invalid line stripped
    # grep -v '^#' $_mirrorlist_path | grep '^\w\+\W\+\w\+\W\+$'
    grep -v '^#' $_mirrorlist_path
}

_is_installed(){
    # _is_installed pkgname
    # fail if pkgname is not installed yet
    cut -d " " -f 1 $_installed_db | grep --line-regexp "$1" >/dev/null 2>&1
}

# FIXME: make the variable naming consistent: proceeding __ for local variables


##############################
# sync operations: install packages, search packages including uninstalled

_help_sync(){
    cat <<__EOC__
usage: pac-cyg -S [<option> ...] [<target> ...]

options:
    -s <query>   Search repositories
    -i <package> Show infos about packages
    -y           Update repository databases
    -h           Print this help

No option to install TARGET.
__EOC__
}

do_sync(){
    __search=
    __update=
    __upgrade=
    __info=
    if test "$1" = "-"
    then
        shift 1
    else
        unset OPTIND
        while getopts syuih opt2
        do
            case "$opt2" in
                s) __search=1;;
                y) __update=1;;
                u) __upgrade=1;;
                i) __info=1;;
                h) _help_sync; return 0;;
                *) _help_sync; return 1;;
            esac
        done

        shift `expr $OPTIND - 1`
    fi

    if test -z "$__search" -a -z "$__update" -a -z "$__upgrade" -a -z "$__info"
    then
        for pkg in "$@"
        do
            if _is_installed "$pkg"
            then
                _msg Package $pkg is already installed, skipping
            else
                _install_package "$pkg"
            fi
        done
        return 0
    fi

    if test -n "$__update"
    then
        _cat_mirrorlist | while read repname url
        do
            _update_pkglist $url
        done
    fi

    if test -n "$__upgrade"
    then
        _warn Updating feature is not supported yet. Use setup.exe .
    fi

    if test -n "$__search"
    then
        _cat_mirrorlist | while read repname url
        do
            _msg "repository [$repname]"
            if test $# -eq 0
            then
                awk '$0 = $1' RS='\n\n@ ' FS='\n' \
                    `_get_cache_dir $url`/setup.ini
            else
                for pkg in "$@"
                do
                    awk '$1 ~ query && $0 = $1' RS='\n\n@ ' FS='\n' query="$pkg" \
                        `_get_cache_dir $url`/setup.ini
                done
            fi
        done
    fi

    if test -n "$__info"
    then
        _cat_mirrorlist | while read repname url
        do
            _msg "repository [$repname]"
            for pkg in "$@"
            do
                awk '$1 == query {print $0}' RS='\n\n@ ' FS='\n' query="$pkg" \
                    `_get_cache_dir $url`/setup.ini
                echo
            done
        done
    fi

}

_update_pkglist()
{
    # _update_pkglist <mirror>
    # fetch latest setup.ini from mirror
    # TODO: use md5.sum to check if updated
    __dir=`_get_cache_dir $1`
    if _download $1/$_arch/setup.bz2 $__dir/_setup.bz2 && \
        test -e $__dir/_setup.bz2
    then
        bunzip2 $__dir/_setup.bz2
        mv $__dir/_setup $__dir/setup.ini
        _msg Package list updated
    elif _download $1/$_arch/setup.ini $__dir/_setup.ini && \
        test -e $__dir/_setup.ini
    then
        mv $__dir/_setup.ini $__dir/setup.ini
        _msg Package list updated
    else
        _die Error updating package list
    fi
}

_install_package(){
    # query one package for install
    # check all available mirrors and install required packages
    # install all dependant packages from same mirrors
    pkg=$1
    _cat_mirrorlist | while read repname url
    do
        if _make_desc_or_fail $pkg $url
        then
            _msg $pkg is found in $mirror
            _install_recursively_with_mirror $pkg $url
            break
        else
            _warn $pkg is not found in $mirror
        fi
    done
    _run_postinstall_scripts
}

_run_postinstall_scripts(){
    # run all postinstall scripts

    pis=`ls /etc/postinstall/*.sh 2>/dev/null | wc -l`
    if (( pis ))
    then
        _msg Running postinstall scripts
        for script in /etc/postinstall/*.sh
        do
            sh $script
            mv $script $script.done
        done
    fi

}

_make_desc_or_fail(){
    # _make_desc_or_fail pkgname mirror
    # If PKGNAME is found in MIRROR, make desc file for that.
    # Otherwise, return 1
    pkg=$1
    mirror=$2
    __dir="`_get_cache_dir $mirror`"
    __pkgdir=$__dir/release/$pkg

    # look for package and save desc file
    mkdir -p $__pkgdir
    awk '
            $1 == package {
                desc = $0
                px++
            }
            END {
                if (px == 1 && desc) print desc
                else print "Package not found"
            }
        ' RS='\n\n@ ' FS='\n' package="$pkg" `_get_cache_dir $mirror`/setup.ini \
            > "$__pkgdir/desc"
    if test "`cat $__pkgdir/desc`" = 'Package not found'
    then
        rm -r $__pkgdir
        return 1
    fi
}

_install_recursively_with_mirror(){
    # _install_recursively_with_mirror pkg mirror
    # desc file is already prepared
    pkg=$1
    mirror=$2
    __dir="`_get_cache_dir $mirror`"
    __pkgdir=$__dir/release/$pkg

    _msg Start installing $pkg

    # download and unpack the bz2 or xz file

    # pick the latest version, which comes first
    __arch_relative_path=$(awk '/^install: / {print $2; exit}' "$__pkgdir/desc")

    if test -z "$__arch_relative_path"
    then
        _msg Cannot find archive file for $pkg in $mirror
        return 0
    fi
    __arch_url="$mirror/$__arch_relative_path"
    # __arch_output="$__dir/../$__arch_relative_path"

    __arch_basename=`basename $__arch_relative_path`
    __arch_output="$__pkgdir/$__arch_basename"
    __md5sum=$(awk '/^install: / {print $4; exit}' $__pkgdir/desc)

    if test -e "$__arch_output" && \
        test $(md5sum $__arch_output | awk NF=1) = $__md5sum
    then
        _msg $__arch_basename already downloaded. skip

    elif _download $__arch_url $__arch_output && \
        test $(md5sum $__arch_output | awk NF=1) = $__md5sum
    then
        # file donwloaded without any error
        true

    else
        _msg downloading $__filebase failed
        return 1
    fi


    _msg "Unpacking $__arch_output ..."
    tar xvf $__arch_output -C / | gzip > "$_setupdir/$pkg".lst.gz


    # update installed.db
    awk '
    ins != 1 && pkg < $1 {
      printf "%s %s 0\n", pkg, bz
      ins=1
    }
    1
    END {
      if (ins != 1) printf "%s %s 0\n", pkg, bz
    }
    ' pkg="$pkg" bz=$__arch_output $_installed_db > /tmp/awk.$$
    mv $_installed_db{,.bak}
    mv /tmp/awk.$$ $_installed_db

    _msg Package $pkg installed

    # recursively install required packages

    requires=$(awk '
    $0 ~ rq {
      sub(rq, "")
      print
    }
    ' rq='^requires: ' "$__pkgdir/desc")
    warn=0
    if (( ${#requires} ))
    then
        _msg Package $pkg requires the following packages, installing:
        echo " " $requires

        for require in $requires
        do
            if _is_installed $require
            then
                _msg Package $require is already installed, skipping
                continue
            fi
            if _make_desc_or_fail $require $mirror
            then
                _install_recursively_with_mirror $require $mirror
                (( $? && warn++ )) || true
            else
                _warn $require not found in $mirror
                _warn $check another mirrors
                _install_package $require
                (( $? && warn++ )) || true
            fi
        done
    fi
    if (( warn ))
    then
        _warn 'Warning: some required packages did not install, continuing'
    fi
}




##############################
# query installed packages

_help_query(){
    cat <<__EOC__
usage: pac-cyg -Q [<option> ...] [<target> ...]

options:
    -s <query>   Search installed packages
    -i <package> Show infos about installed packages (very simple, use -Si for
                 details)
    -o <file>    Find package that has given files or commands
    -l <package> List files owned by packages
    -h           Print this help

No option to show all installed packages.
__EOC__
}

do_query(){
    __search=
    __info=
    __own=
    __list=
    if test "$1" = "-"
    then
        shift 1
    else
        unset OPTIND
        while getopts siolh opt2
        do
            case "$opt2" in
                s) __search=1;;
                i) __info=1;;
                o) __own=1;;
                l) __list=1;;
                h) _help_query; return 0;;
                *) _help_query; return 1;;
            esac
        done

        shift `expr $OPTIND - 1`
    fi

    if test -z "$__search" -a -z "$__info" -a -z "$__own" -a -z "$__list"
    then
        # list all instaled packages
        awk 'NR>1 && $0=$1' $_installed_db
        return 0
    fi

    if test -n "$__search"
    then
        for pkg in "$@"
        do
            awk 'NR>1 && $1~query && $0=$2' query="$pkg" $_installed_db | \
                sed -e 's/\.tar\..*//'
        done
    fi

    if test -n "$__info"
    then
        # NOTE: only shows package name and version
        for pkg in "$@"
        do
            awk 'NR>1 && $1 == query && $0=$2' query="$pkg" $_installed_db | \
                sed -e 's/\.tar\..*//'
        done
    fi

    if test -n "$__own"
    then
        for e in "$@"
        do
            key=$(command -v "$e" | sed s./..)
            if (( ! ${#key} ))
            then
                key=$e
            fi
            for manifest in "$_setupdir"/*.lst.gz
            do
                found=$(gzip -cd $manifest | grep -c "$key" || true)
                if (( found ))
                then
                    package=$(sed '
          s,/etc/setup/,,
          s,.lst.gz,,
          ' <<< $manifest)
                    _msg Found $key in the package $package
                    break
                fi
            done
        done
    fi

    if test -n "$__list"
    then
        for pkg in "$@"
        do
            zcat "$_setupdir"/"$pkg".lst.gz 2>/dev/null \
                || _warn Package not found: "$pkg"
        done
    fi
}


###############################
# remove packages

_help_remove(){
    cat <<__EOC__
usage: pac-cyg -R [<option> ...] [<target> ...]

options:
    -h    Print this help
__EOC__
}

do_remove(){
    __recursive=
    if test "$1" = "-"
    then
        shift 1
    else
        unset OPTIND
        while getopts sh opt2
        do
            case "$opt2" in
                s) __recursive=1;;
                h) _help_remove; return 0;;
                *) _help_remove; return 1;;
            esac
        done

        shift `expr $OPTIND - 1`
    fi

    if test "$#" -lt 1
    then
        _warn No packages to remove
        return 0
    fi

    if test -n "$__recursive"
    then
        _warn Recursive remove is not currently supported.
        _warn "-s" option is ignored.
    fi

    _msg Removing these packages:
    echo
    echo " " "$@"
    echo
    if _ask "Really remove these packages? [y/N]" n
    then
        for pkg in "$@"
        do
            _remove_package "$pkg"
        done
    else
        _warn Abort.
    fi
}

_remove_package(){
    # _remove_package pkg
    # remove one package
    pkg=$1
    if ! _is_installed "$pkg"
    then
        _warn Package $pkg is not installed, skipping
        return 0
    fi
    for req in cygwin coreutils gawk bzip2 tar bash
    do
        if [[ $pkg = $req ]]
        then
            _warn apt-cyg cannot remove package $pkg, skipping
            return 0
        fi
    done
    if [ ! -e "$_setupdir/$pkg.lst.gz" ]
    then
        _warn Package manifest missing, cannot remove $pkg. skipping
        return 0
    fi

    _msg Removing $pkg

    # run preremove scripts

    if [ -e "/etc/preremove/$pkg.sh" ]
    then
        "/etc/preremove/$pkg.sh"
        rm "/etc/preremove/$pkg.sh"
    fi
    gzip -cd "$_setupdir/$pkg.lst.gz" |
    awk '/[^\/]$/ {print "rm -f \"/" $0 "\""}' | sh
    rm "$_setupdir/$pkg.lst.gz"
    rm -f /etc/postinstall/$pkg.sh.done
    awk '$1 != pkg' pkg="$pkg" $_installed_db > /tmp/awk.$$
    mv ${_installed_db}{,-save}
    mv /tmp/awk.$$ $_installed_db
    _msg Package $pkg removed
}

############################
# help

function do_help()
{
    cat <<__EOC__
usage: pac-cyg <operation> [<option> ...] [<target> ...]

Operations:
    -S    Sync packages
    -Q    Query installed packages
    -R    Remove packages
    -V    Show version

use 'pac-cyg -h' with an operation for available options
__EOC__
}


########################
# version

function do_version()
{
    cat <<__EOC__
pac-cyg v$_version
Copyright (C) 2014 10sr

This program may be freely redistributed under
the terms of the GNU General Public License.
__EOC__
}


######################################3
# main

main(){
    # (currently) useless check: _detect_arch() always returns something
    if test -z "$_arch"
    then
        _die "Cannot detect architecture for this environment."
    fi

    _check_prepare_mirrorlist

    __ope=
    __opts=
    __help=

    unset OPTIND
    while getopts SQRVsyuiolh opt
    do
        case "$opt" in
            S) __ope=sync;;
            Q) __ope=query;;
            R) __ope=remove;;
            V) __ope=version;;
            s|y|u|i|o|l) __opts=$__opts$opt;;
            h) __help=1; __opts=$__opts$opt;;
            *) do_help; return 1;;
        esac
    done

    shift `expr $OPTIND - 1`

    # if no operations given and -h is given
    if test -z "$__ope" -a -n "$__help"
    then
        do_help
        return 0
    fi

    case "$__ope" in
        sync) do_sync -"$__opts" "$@";;
        query) do_query -"$__opts" "$@";;
        remove) do_remove -"$__opts" "$@";;
        version) do_version -"$__opts" "$@";;
        *) do_help -"$__opts" "$@"; return 1;;
    esac
}

_arch=`_detect_arch`
main "$@"
